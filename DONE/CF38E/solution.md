题目翻译

有n个弹珠，第i个弹珠的坐标为x_i，使第i个弹珠固定不动的花费为c_i，x_i,c_i在int范围内有可能为负数。开始前需要指出哪些弹珠不动，开始之后所有没被1固定的弹珠都会向左移动，知道碰到被固定的弹珠，开始后的花费是所有的弹珠滚动的距离之和，总的花费是开始前的花费和开始后的花费之和，求结束最小的花费。

首先我们要把输入处理，按照坐标先从小到大排序。拿到题目之后，首先能肯定这不是贪心。所以我们考虑DP。首先考虑固定点，因为固定点之间的花费是一定的。首先我想到了区间dp，也就是第i个点作为固定点，第j个点作为固定点，i-j这个区间需要的花费。但是观察点的数目，有3000个，而区间dp是n^3级别的，所以应该不是区间dp。但是枚举固定点这个思路应该是正确的。(本来还想到了区间i-j之间第一个和最后一个固定点是k和l的，但是发现更复杂，就没这么想了)。所以这时候我们大概就有一个方向，考虑枚举目前的区间和目前这个区间的首位两个弹珠。我们可以发现这个题目并没必要枚举区间，因为这个题所有的弹珠会向左移动，所以从小到大排序之后的第一个点一定会被固定，否则游戏代价为无限大。那么刚才的区间就出来了，也就是dp[j]表示第1个点到第j个点，并且第j个点作为固定点的时候的最小代价。那么这样作为这状态的答案是什么呢？显然不是dp[n]，因为n不一定是固定点。而且换言之，3000的数据时间复杂度怎么可能是On，所以考虑$dp[i][j]$表示1-i的区间，最后一个固定点是j的最小代价。所以我们能知道，$dp[1][1]=a[1].c$。然后枚举区间，枚举最后一个点，当前状态从比他编号小1的点推过来。

所以状态转移就是
$$
dp[i][j]=min(dp[i-1][j])+C[i](i==j)\\
dp[i][j]=dp[i-1][j]+a[i].x-a[j].x
$$
